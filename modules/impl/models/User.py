"""
  Copyright (c) 2025 Alexandre Kavadias 

  This project is licensed under the Educational and Non-Commercial Use License.
  See the LICENSE file for details.
"""
"""
Model: User

This file defines the 'User' domain model using Python's dataclasses.
In a clean architecture, **domain models are the core business entities**
that represent the essential concepts of your application.

They are:
- Database Agnostic: A User object doesn't care if it came from SQLite, PostgreSQL,
  or a web API. It only represents a user.
- Persistence Ignorant: It contains the data and behavior relevant to a 'User'
  in your business domain, without knowing *how* it's stored or retrieved.
- Encapsulate Domain Logic: Can include methods for validation (e.g., `is_valid_email()`)
  or business rules specific to a user (e.g., `verify_password()`).
- Data Transfer Objects (DTOs) for the Application: They serve as structured data
  that is passed between different layers of your application (e.g., from a Repository
  to a Service, or from a Service to a presentation layer).

By defining these models, we achieve:
- Improved Type Safety: Work with `user.username` instead of generic dictionary keys.
- Readability: Code that operates on `User` objects is more intuitive.
- Decoupling: Changes to the database schema or DAO implementation don't
  require changes in higher-level application logic that uses User objects.
"""

from dataclasses import dataclass, field
from datetime import datetime

@dataclass
class User:
    """
    Represents a user from Table users.
    """
    id: int = field(default=None) # Use default=None for fields that might be auto-generated by DB
    username: str = field(default=None)
    password_hash: str = field(default=None)
    email: str = field(default=None)
    created_at: datetime = field(default_factory=datetime.now) # Default to current time for new users

    def __post_init__(self):
        # This method is called after __init__ is generated by dataclass.
        # It's useful for post-processing arguments, e.g., converting string dates from DB.
        if isinstance(self.created_at, str):
            try:
                # SQLite stores DATETIME as TEXT in 'YYYY-MM-DD HH:MM:SS' format typically
                self.created_at = datetime.fromisoformat(self.created_at)
            except ValueError:
                # Handle cases where the format might be slightly different
                # or if it includes microseconds (e.g., 'YYYY-MM-DD HH:MM:SS.SSSSSS')
                # For SQLite, it's often simpler to just cut off microseconds if present
                if '.' in self.created_at:
                    self.created_at = datetime.fromisoformat(self.created_at.split('.')[0])
                else:
                    raise # Re-raise if it's still not a valid format
        
        # Domain-specific validation
        if self.username is not None and not self.username.strip():
            raise ValueError("Username cannot be empty.")
        if self.email is not None and "@" not in self.email:
            raise ValueError("Invalid email format.")

    def to_dict(self):
        """Converts the User object to a dictionary, useful for API responses or logging."""
        return {
            "id": self.id,
            "username": self.username,
            "email": self.email,
            "created_at": self.created_at.isoformat() if self.created_at else None
        }

    # Domain-specific method to verify password
    def verify_password(self, password: str) -> bool:
        """Placeholder for actual password verification."""
        # In a real app, you would use a robust hashing library 
        return self.password_hash == f"hashed_{password}"